#include <stdio.h>
#include <string.h>
#include <math.h>
#include <codecvt>
#include <locale>
#include <stdexcept>

#include <ft2build.h>
#include FT_FREETYPE_H

#define WIDTH   800//640
#define HEIGHT  480

#include <jfc/unique_handle.h>

#include <jfc/glfw_window.h>

#include <gdk/graphics_context.h>
#include <gdk/webgl1es2_entity.h>
#include <gdk/webgl1es2_material.h>
#include <gdk/webgl1es2_model.h>
#include <gdk/webgl1es2_texture.h>

#include <GLFW/glfw3.h>

using namespace gdk;

/* origin is the upper left corner */
unsigned char image[HEIGHT][WIDTH];

/* Replace this function with something useful. */
void draw_bitmap(FT_Bitmap *bitmap,
    FT_Int x,
    FT_Int y)
{
    FT_Int  i, j, p, q;
    FT_Int  x_max = x + bitmap->width;
    FT_Int  y_max = y + bitmap->rows;

    /* for simplicity, we assume that `bitmap->pixel_mode' */
    /* is `FT_PIXEL_MODE_GRAY' (i.e., not a bitmap font)   */
    for ( i = x, p = 0; i < x_max; i++, p++ )
    {
        for ( j = y, q = 0; j < y_max; j++, q++ )
        {
            if ( i < 0 || j < 0 || i >= WIDTH || j >= HEIGHT ) continue;

            image[j][i] |= bitmap->buffer[q * bitmap->width + p];
        }
    }
}

int main(int argc, char **argv)
{
    if (argc !=2)
    {
        fprintf ( stderr, "usage: %s font sample-text\n", argv[0] );
        exit(1);
    }

    ////////////////

    jfc::unique_handle<FT_Library> hLibrary([]()
        {
            FT_Library library;

            if (auto error = FT_Init_FreeType( &library ))
            {
                throw std::invalid_argument("FreeType could not initialize");
            }
            
            return library;
        }(),
        [](const FT_Library library)
        {
            FT_Done_FreeType(library);
        }
    );

    jfc::unique_handle<FT_Face> hFace([argv, &hLibrary]()
        {
            char *filename = argv[1];

            FT_Face face;

            //TODO load from memory buffer. do not use porcelain
            if (auto error = FT_New_Face( hLibrary.get(), filename, 0, &face ))
            {
                //TODO make this more robust
                throw std::invalid_argument("Could not load font file");
            }

            if (auto error = FT_Set_Char_Size(face, 
                30 * 64, //char width. 64 converst from fixed-point subpixel val
                0, //char height  (zero defaults to w size)
                0, //horizontal res
                0)) //vertical res
            {
                throw std::invalid_argument("Could not set charsize");
            }

            return face;
        }(),
        [](const FT_Face face)
        {
            FT_Done_Face(face);
        }
    );
    
    /* cmap selection omitted;                                        */
    /* for simplicity we assume that the font contains a Unicode cmap */
    FT_GlyphSlot slot = hFace.get()->glyph;

    /* set up matrix */
    FT_Matrix matrix;

    const double angle(0);

    matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
    matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
    matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
    matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

    /* the pen position in 26.6 cartesian space coordinates; */
    FT_Vector pen; /* untransformed origin  */

    int target_height;
    target_height = HEIGHT;

    pen.x = 0;
    pen.y = (target_height - 30) * 64;

    // u8 data and conversion
    std::string narrowJapanese("世界お早うございます"); //u8 data
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t> convertWindows;
    std::wstring text = convertWindows.from_bytes(narrowJapanese);  //u16, needed by the library.

    for (const auto &current_char : text)
    {
        FT_Set_Transform(hFace.get(), &matrix, &pen);

        if (const auto error = FT_Load_Char(hFace.get(), current_char, FT_LOAD_RENDER)) continue; // ignore errors

        /* now, draw to our target surface (convert position) */
        draw_bitmap(&slot->bitmap,
            slot->bitmap_left,
            target_height - slot->bitmap_top);

        /* increment pen position */
        pen.x += slot->advance.x;
        pen.y += slot->advance.y;
    }

    //////////////////////////////////////////

    glfw_window window("cool demo");
    
    auto pContext = graphics::context::make(graphics::context::implementation::opengl_webgl1_gles2);    

    gdk::webgl1es2_texture::webgl1es2_texture_2d_data_view_type view;
    view.width = WIDTH;
    view.height = HEIGHT;
    view.format = webgl1es2_texture::format::rgba;

    std::vector<std::underlying_type<std::byte>::type> imageData({});
    
    for (int i = 0; i < HEIGHT; i++ )
    {
        for (int j = 0; j < WIDTH; j++ )
        {
            imageData.push_back(image[i][j]);
            imageData.push_back(image[i][j]);
            imageData.push_back(image[i][j]);
            imageData.push_back(0xff);
        }
    }

    view.data = reinterpret_cast<std::byte *>(&imageData.front()); 

    std::shared_ptr<webgl1es2_texture> pTexture(new webgl1es2_texture(view));

    auto pModel = std::shared_ptr<webgl1es2_model>(webgl1es2_model::Quad);
    
    auto pMaterial = std::shared_ptr<webgl1es2_material>(new webgl1es2_material(webgl1es2_shader_program::AlphaCutOff));
    
    pMaterial->setTexture("_Texture", pTexture);

    auto pEntity = std::shared_ptr<entity>(std::move(pContext->make_entity(pModel, pMaterial)));

    auto pCamera = std::shared_ptr<camera>(std::move(pContext->make_camera()));
    pCamera->setProjection(90, 0.001, 20, 1);

    auto pScene = pContext->make_scene();
    
    pScene->add_camera(pCamera);
    pScene->add_entity(pEntity);

    //////////////////////////////////////////

    while(!window.shouldClose())
    {
        glfwPollEvents();

        pEntity->set_model_matrix(Vector3<float>{-0.3, -0.5, -0.5}, Quaternion<float>{});

        /*pCamera->set_view_matrix({std::sin(time), 0, -10}, {});*/

        pScene->draw(window.getWindowSize());

        window.swapBuffer(); 
    }

    return 0;
}

/* EOF */

